# 算法的定义

    对于特定问题求解方法和步骤的一种描述，它是指令的有限序列

    其中每个指令表示一个或多个操作。
---

# 算法的描述

自然语言： 英语、中文

    算法，求一元二次方程的根
        1、输入方程的系数a,b,c
        2、判断a是否等于零。如果等于零，则提示不是一元二次方程，
            不等于零，则执行第三步
        3、计算 d = b^2 - 4ac
        4、判断d。如果d等于零，计算并输入两个相等实根。如果d小于零，
            输出没有实根。如果d大于零，输出两个不等实根。
        5、结束 

流程图：传统流程图、NS流程图

伪代码：类语言：类C语言

程序代码：C语言程序...

---
# 算法与程序

    算法是解决问题的一种方法或一个过程，考虑如何将输入转换成输出
    一个问题可以由多种算法

    程序是用某种程序设计语言对算法的具体实现
        程序 = 数据结构 + 算法
            数据结构通过算法实现操作
            算法根据数据结构设计程序

---

# 算法特性：一个算法必须具备以下五个重要特性

    有穷性
        一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
    
    确定性
        算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
    
    可行性 
        算法是可行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
    
    输入
        一个算法有零个或多个输入
    
    输出
        一个算法有一个或多个输出
---

# 算法设计的要求

**正确性(Correctness)**

    算法满足问题要求，能正确解决问题，算法转化为程序后要注意：
        1、程序中不含语法错误；
        2、程序对于几组输入数据能够得出满足要求的结果
        3、程序对于精心选择的、典型、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果
        4、程序对于一切合法的输入数据 都能得出满足要求的结果通常以第三层意义上的正确性作为衡量一个算法是否合格的标准

**可读性(Readability)**

    1、算法主要是为了人的阅读和交流，其次才是为计算机执行，因此算法应该易于人的理解；
    2、另一方面，晦涩难懂的算法易于隐藏较多错误而难以调试；

**健壮性(Robustness)**

    1、指当输入非法数据时，算法恰当的做出反应或进行相应处理，
        而不是产生莫名其妙的的输出结果
    2、处理出差的方法，不应是中断程序的执行，而应是返回一个表示
        错误或错误性质的值，以便在更高的抽象层次上进行处理

**高效性(Efficiency)**

    要求花费尽量少的时间和尽量低的存储需求
---
# 4.1
# 算法分析

    对于同一个问题，可以有许多不同的算法。究竟如何来评价这些算法优劣程度？

    算法分析的目的是看算法实际是否可行，并在同一问题存在多的
        算法时可进行性能上的比较，以便从中挑选出比较优的算法。

    一个好的算法首先要具备正确性、然后是健壮性、可读性，在几个
        方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评价不同算法的优劣程度

    算法效率以下两个方面来考虑：
        1、时间效率：算法所耗费的时间
        2、空间效率：算法执行过程中所耗费的存储空间

        时间效率和空间效率有时候是矛盾的
---
# 算法的时间效率的度量

    算法时间效率可以用依据该算法编制的程序在计算机上执行 所耗费的时间 来度量

    两种度量方法
        事后统计
            将算法实现，测算其时间和空间开销

            缺点
                编写程序实现算法将花费较多的时间和精力；
                所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣

        事前分析
            对算法所消耗资源的一种估算方法
---
# 事前分析方法

    一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于

        计算机执行一种简单的操作<如赋值、比较、移动等>所需的时间与算法中进行的简单操作次数乘积

            算法运行时间 = 一个简单操作所需的时间 * 简单操作次数

        也即算法中每条语句的执行时间之和

            算法运算时间 = 每条语句的执行次数<语句频度> * 该语句执行一次所需的时间

                每条语句执行一次所需的时间，一般是随机器而异的。取决与机器的指令性能、  
                速度以及编译的代码质量。是由机器本身软硬件环境决定的，它与算法无关；

                所以，我们可以 假设执行每条语句所需的时间均为 单位时间。此时对算法
                的运行时间的讨论就可以转化为讨论该算法中所有语句的执行次数，即频度之和了；

                这就可以独立于不同机器的软硬件环境来分析算法的时间性能了；

---

例如：两个n*n矩阵相乘的算法可描述为

```
for(i = 1; i <= n; i++)                                 // n + 1
    for(j = 1; j <=n; j++){                             // n(n + 1)
        c[i][j] = 0;                                    // n * n
        for(k = 0; k < n; k++)                          // n * n * (n + 1)
            c[i][j] = c[i][j] + a[i][k] * b[k][j];      // n * n * n
    }
```

    我们把算法所耗费的时间定义为 该算法中每条语句的频度之和，则上述算法
        的时间消耗 T(n) 为
            T(n) = 2n^3 + 3n^2 + 2n + 1

---
# 算法时间复杂度的渐进表示法

为了便于比较不同算法的时间效率，我们仅比较它们的数量级

    例如：两个不同的算法，时间消耗分别是 
        T1(n) = 10n^2   与  T2(n) = 5n^3

若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为

    不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n) = O(f(n)),
    称O(f(n))为 算法的渐进时间复杂度 (O是数量级的符号<Order>)，简称 时间复杂度

对于求解矩阵相乘问题，算法耗费时间：

    T(n) = 2n^3 + 3n^2 + 2n + 1
    n -> (无穷大)时，T(n) / n^3 -> 2，这表示n充分大时，T(n)与n^3时同阶或同数量级，

        引入大"O"记号，则T(n)可记作：
            T(n) = O(n^3)   这就是求解矩阵相乘问题的算法的渐进时间复杂度

    一般情况下，不必计算所有操作的执行次数，而只考虑算法中基本操作执行的次数，

        它的问题规模n的某个函数，用T(n)表示；

---
# 算法时间复杂度定义

    算法中 基本语句重复执行的次数 是 问题规模n 的某个函数f(n)，
        算法的时间度量记作：    T(n) = O(f(n))

    它表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称 渐进时间复杂度


    数学符号"O"的定于为：

        若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n) = O(f(n))表示存在正的常熟C和No，使得当 n >= No是都满足 O <= T(N) <= Cf(n) 

    基本语句重复执行的次数

        算法中重复执行次数和算法的执行时间成正比的语句
        对算法运行时间的贡献最大
        执行次数最多

    问题规模n

        n越大算法的执行时间越长
            排序： n为记录数
            矩阵： n为矩阵的阶数
            多项式： n为多项式的项数
            集合： n为元素的个数
            树： n为树的结点个数
            图： n为图的顶点树或边数  

---
# 4.2

# 算法的渐进时间复杂度

若有某个辅助函数f(n)，使得当n趋近与无穷大时，T(n)/f(n)的极限值为**不等与零的常数**，则称f(n)时T(n)的同数量级函数。记作  T(n) = O(f(n))

称 O(f(n)) 为**算法的渐进时间复杂度**(O是数量级的符号)，简称**时间复杂度**

一般情况下，不必计算所有操作的执行次数，而只考虑算法中**基本操作**执行的次数，它是问题规模n的某个函数，用T(n)表示

## 定理

若 f(n) = a^mn^m + a^m-1n^m-1+...+a^1n+a^0是m次多项项式，

    则T(n) = O(n^m) 

    忽略所有低次幂项和最高次幂系数，体现出增长率的含义

---

# 分析算法时间复杂度的基本方法

    1、找出 语句频度最大 的那条语句作为 基本语句
    2、计算 基本语句 的频度得到问题规模n的某个函数f(n)
    3、取其数量级用符号"O"表示

```
x = 0; y = 0;
for(int k = 0; k < n; k++)          // n + 1
    x++;                            // n
for(int i = 0; i < n; i++)          // n + 1
    for(int j = 0; j < n; j++)      // n * (n + 1)
        y++;                        // n * n
```

```
// 时间复杂度是由嵌套最深层语句的频度决定的
void exam(float x[][], int m, int n){
    float sum[];
    for(int i = 0; i < m; i++){
        sum[i] = 0.0;
        for(int j = 0; j < n; j++)
            sum[i] += x[i][j];      // m * n
    }
    for(i = 0; i < m; i++)
        cout << i << ":" << sum[i] << endl;
}
```

```
// N * N 矩阵相乘
// 算法中的基本操作语句为 c[i][j] = c[i][j] + a[i][k] * b[k][j];
for(i = 1; i <= n; i++)
    for(j = 1; j <= n; j++){
        c[i][j] = 0;
        for(k = 1; k <= n; k++)
            c[i][j] = c[i][j] + a[i][k] * b[k][j];  // O(n^3)
    }
```

```
for(i = 1; i <= n; i++)
    for(j = 1; j <= i; j++)
        for(k = 1; k <= j; k++)
            x = x + 1;
/*
    2/1{n(n+1)(2n+1)/6 + n(n+1)/2}
    = n(n+1)(n+2)/6
    = n^3
*/
```

```
i = 1;
while(i <= n)
    i = i * 2;
/*
    关键是要找出来执行次数 x 与 n 的关系，并表示称n的函数
    执行1次： i = 1 * 2 = 2；
    执行2次： i = 2 * 2 = 2^2；
    执行3次： i = 2 * 2 = 2^3；
    ...
    执行x次： i = 2^x
    设**语句 i = i * 2;**执行次数为x次，由循环条件
    i <= n; 2^x <= n; x = log^2n 
    
    2^f(n) <= n;
    即f(n) <= log^2n, 取最大值f(n) = log^2n
    所以该程序段的时间复杂度 T(n) = O(log^2n)
*/
```

# 4.3

# 算法时间复杂度计算

    请注意：有的情况下，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同。 

    例如：顺序查找，在数组a[i]中查找值等于e的元素，返回其所在位置

```
for(i = 0; i < n; i++)
    if(a[i] == e)
    return i + 1;   // 找到，则返回是第几个元素
return 0;
```

    最好情况：1次   最坏情况：n次   平均时间复杂度为：O(n)

---

# 算法时间复杂度

**最坏时间复杂度**

    指在最坏情况下，算法的时间复杂度

**平均时间复杂度**

    指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间

**最好时间复杂度** 

    指在最好情况下，算法的时间复杂度

一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长

**对于复杂的算法，可以将它分成几个容易估算的部分，**
**然后利用大O加法法则和乘法法则，计算算法的时间复杂度**

a>  加法法则
    T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))

b>  乘法法则
    T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n)* g(n))

---

# 算法时间的比较

当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊

---
# 时间复杂度 T(n) 按数量级递增顺序为


常熟阶      对数阶          线性阶  

O(1)        O(log^2 n)      O(n)        

线性对阶        平方阶      立方阶      

O(n log^2 n)    O(n^2)      O(n^3)     

K次方阶     指数阶

O(n^k)      O(2^n)

# 渐进空间复杂度

空间复杂度：算法所需存储空间的度量

    记作： S(n) = O(f(n))
    其中n为问题的规模(大小)

算法要占据的空间
    算法本身要占据的空间，输入/输出、指令、常数、变量等
    算法要是有的辅助空间

---

将一维数组a中的n个数逆序放到原数组中

```
for(i = 0; i < n/2; i++){
    t = a[i];
    a[i] = a[n-i-1];
    a[n-i-1] = t;
}
/*
    t    S(n) = O(1)     原地工作
*/
```    

```
for(i = 0; i < n; i++)
    b[i] = a[n-i-1];
for(i = 0; i < n; i++)
    a[i] = b[i];
/*
    b[i]    S(n) = O(n)
*/
```